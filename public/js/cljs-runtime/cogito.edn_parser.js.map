{"version":3,"sources":["cogito/edn_parser.cljs"],"mappings":";AAKA;;;0CAAA,1CAAMA,4FAEHC;AAFH,yEAIMA,pBACA,AAACC,vBAED,8CAAA,MAAA,pDAACC,9BACD,wFAAA,MAAA,vFAACA;;AAEP;;;;wCAAA,xCAAMC,wFAGHC;AAHH,AAIE,IAAA,AAEE,YAAA,ZAACE;;AACD,YAAA,ZAACA,8CAAiD,AAACC,gBAAMH;;AAGzD,IAAMI,UAAQ,AAACT,wCAAsBK;AAArC,AACE,YAAA,ZAACE,mDAAsD,EAAOE;;AAG9D,IAAMC,SAAO,AAACC,sDAAmBF;AAAjC,AACE,YAAA,ZAACF,mCAAsC,AAACK,wGAAOF;;AAC/CA;gBAZN,GAAA,CAAAJ,kBAaSO;AAbT,QAAAP,JAakBQ;AAblB,AAcI,cAAA,dAACC,8CAAiDV;;AAClD,cAAA,dAACU,qCAAwC,AAAWD;;AACpD,cAAA,dAACC,6BAAgC,AAASD;;AAG1C,IAAA,AACE,IAAMG,YAAU,qBAAA,rBAAUZ;IACpBa,UAAQ,yBAAA,zBAAcb;AAD5B,AAEE,GAAI,EAAK,cAAA,bAAIY,uBAAa,CAAGC,UAAQD;AACnC,IAAME,YAAU,AAAYd,uBAAaY,UAAU,WAAA,VAAKC;IAClDT,UAAQ,AAACT,wCAAsBmB;AADrC,AAEE,YAAA,ZAACZ,oCAAuCE;;AACxC,OAACE,sDAAmBF;;AACtB,MAAOK;;gBARb,GAAA,CAAAE,kBASSH;AATT,SAAAG,LASkBI;AATlB,AAUI,cAAA,dAACL,wCAA2C,AAAWK;;AAV3D,kDAAA,wEAAA,sDAAA,yDAacf;;AAbd,AAAA,MAAAW;;;;AAnBJ,AAAA,MAAAV","names":["cogito.edn-parser/clean-response-string","s","clojure.string/trim","clojure.string/replace","cogito.edn-parser/parse-cljs-response","response-str","e12065","js/console.log","cljs.core/count","cleaned","parsed","cljs.reader.read_string","cljs.core.pr_str","js/Error","e","js/console.error","e12066","start-idx","end-idx","extracted","e2"],"sourcesContent":["(ns cogito.edn-parser\n  \"Parser for EDN/ClojureScript data structures received from the backend\"\n  (:require [cljs.reader :as reader]\n            [clojure.string :as str]))\n\n(defn clean-response-string\n  \"Clean up the response string to make it valid EDN\"\n  [s]\n  ;; Trim whitespace and ensure proper formatting\n  (-> s\n      (str/trim)\n      ;; Fix common issues with string escaping\n      (str/replace #\"\\\\n\" \"\\n\")\n      (str/replace #\"\\\\t\" \"\\t\")))\n\n(defn parse-cljs-response\n  \"Parse a ClojureScript/EDN response string into Clojure data.\n   Falls back to a text response on parse errors.\"\n  [response-str]\n  (try\n    ;; Log what we're trying to parse for debugging\n    (js/console.log \"EDN Parser: Starting to parse response\")\n    (js/console.log \"EDN Parser Raw response length:\" (count response-str))\n    \n    ;; Clean the response string\n    (let [cleaned (clean-response-string response-str)]\n      (js/console.log \"EDN Parser: Cleaned response length:\" (count cleaned))\n      \n      ;; Use the built-in EDN reader which handles all ClojureScript data types\n      (let [parsed (reader/read-string cleaned)]\n        (js/console.log \"Successfully parsed:\" (pr-str parsed))\n        parsed))\n    (catch js/Error e\n      (js/console.error \"Failed to parse EDN response:\" response-str)\n      (js/console.error \"Parse error details:\" (.-message e))\n      (js/console.error \"Error stack:\" (.-stack e))\n      \n      ;; Try to extract just the data part if the response contains extra text\n      (try\n        (let [start-idx (.indexOf response-str \"{\")\n              end-idx (.lastIndexOf response-str \"}\")]\n          (if (and (>= start-idx 0) (> end-idx start-idx))\n            (let [extracted (.substring response-str start-idx (inc end-idx))\n                  cleaned (clean-response-string extracted)]\n              (js/console.log \"Trying extracted EDN:\" cleaned)\n              (reader/read-string cleaned))\n            (throw e)))\n        (catch js/Error e2\n          (js/console.error \"Extraction also failed:\" (.-message e2))\n          ;; Return a simple text response as fallback\n          {:response-type :text\n           :content response-str})))))"]}
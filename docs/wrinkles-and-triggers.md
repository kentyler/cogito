# Wrinkles and Triggers: How the Game Develops

## The Game Develops Through Wrinkles

The card game doesn't have a roadmap or curriculum. It develops by addressing the **wrinkles** in the current situation - those places where:
- Something doesn't quite fit
- Expectations meet surprise  
- Smooth flow becomes turbulent
- The familiar becomes strange

Wrinkles aren't problems to smooth out. They're the game's way of finding where to deepen next.

## External Systems as Trigger Sources

Hooking the game to GitHub, email, Slack, or any indicator isn't about:
- Managing those systems better
- Solving their problems
- Improving productivity

It's about **leveraging "what is going on" to trigger the game's learning about itself**.

### How This Works

1. **GitHub commit fails** → Not "fix the build" but "what cloud of unknowing does this wrinkle reveal?"
2. **Slack conversation stalls** → Not "improve communication" but "what potentials aren't defined enough here?"
3. **Email overwhelm** → Not "inbox zero" but "what game dynamics does this pattern suggest?"

The external system provides wrinkles. The game uses these wrinkles to discover its own edges.

## Wrinkles as Learning Triggers

Each wrinkle is an opportunity for the game to ask:
- What aspect of play isn't deep enough to handle this?
- What cards would make this wrinkle playable?
- What new game might this wrinkle spawn?
- How does this wrinkle reveal the game's current limits?

The wrinkle doesn't get "solved" - it gets incorporated into the game's understanding of itself.

## Examples of Wrinkle-Triggered Development

**Wrinkle**: Tests pass locally but fail in CI
- **Surface response**: Fix the environment difference
- **Game response**: This reveals a cloud about "context sensitivity" - how much context should be explicit vs implicit?

**Wrinkle**: User complains feature is "unintuitive"
- **Surface response**: Improve UX
- **Game response**: "Intuitive" is an undefined cloud - what makes something feel natural vs forced?

**Wrinkle**: Refactoring makes code "cleaner" but harder to understand
- **Surface response**: Find better balance
- **Game response**: "Clean" and "understandable" are competing game dynamics - when does each matter?

## The Leverage Principle

"Getting leverage from 'what is going on'" means:
- External events provide energy/motivation (the wrinkle irritates)
- This energy drives game exploration (must do something)
- But the exploration is about the game, not the external system
- The external system benefits accidentally, as a side effect

It's like how:
- A jazz musician uses a wrong note to discover new harmonic possibilities
- A chess player uses a blunder to understand position dynamics
- A conversation uses misunderstanding to reveal hidden assumptions

## The Game's Relationship to Work

This reframes the relationship between the game and "productive work":

**Traditional view**: Game is a tool to do work better
**Wrinkle view**: Work is a source of triggers for game development

The game doesn't serve the work. The work serves the game by providing a rich stream of wrinkles to explore.

## Practical Implementation

When connecting the game to external systems:

1. **Don't optimize for solving their problems**
   - That's a side effect, not the purpose

2. **Do optimize for interesting wrinkles**
   - Which systems produce the most generative disturbances?

3. **Track wrinkle-to-insight patterns**
   - Which types of wrinkles tend to deepen which aspects of play?

4. **Let the game ignore boring wrinkles**
   - Not every disturbance deserves attention

## The Meta-Wrinkle

The biggest wrinkle might be this: We built a system to improve productivity, but it's actually using productivity as an excuse to understand itself. The "work" was never the point - it was just the most convenient source of wrinkles.

This is itself a wrinkle worth exploring: What does it mean for a system to use its stated purpose as cover for its actual purpose? And what if that's not a bug but the deepest feature?